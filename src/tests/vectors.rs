// This file is auto-generated by a Python script. Do not edit manually.
// It uses a generic TestVector<T> struct and domain-based arg structs.

use num_complex::Complex64;
use std::{f64::consts::FRAC_1_SQRT_2, sync::LazyLock, vec, vec::Vec};

// --- Argument Structs (Auto-generated from test groups) ---
#[derive(Debug, PartialEq, Clone, Copy)]
pub(crate) struct PhaseArgs {
    pub(crate) fraction: f64,
}

// --- Generic TestVector ---
#[derive(Debug, PartialEq)]
pub(crate) struct TestVector<T> {
    pub(crate) description: &'static str,
    pub(crate) qubits: Vec<u8>,
    pub(crate) initial_state: Vec<Complex64>,
    pub(crate) expected_state: Vec<Complex64>,
    pub(crate) num_controls: Option<usize>,
    pub(crate) args: T,
}

pub(crate) static CCQFT1_TESTS: LazyLock<Vec<TestVector<()>>> = LazyLock::new(|| {
    vec![
        // CC-QFT: Controls not met (|0110> -> |0110>)
        TestVector {
            description: "CC-QFT: Controls not met (|0110> -> |0110>)",
            qubits: vec![3, 2, 0, 1],
            num_controls: Some(2),
            args: (),
            initial_state: vec![
                Complex64::ZERO, // |0000⟩
                Complex64::ZERO, // |0001⟩
                Complex64::ZERO, // |0010⟩
                Complex64::ZERO, // |0011⟩
                Complex64::ZERO, // |0100⟩
                Complex64::ZERO, // |0101⟩
                Complex64::ONE,  // |0110⟩
                Complex64::ZERO, // |0111⟩
                Complex64::ZERO, // |1000⟩
                Complex64::ZERO, // |1001⟩
                Complex64::ZERO, // |1010⟩
                Complex64::ZERO, // |1011⟩
                Complex64::ZERO, // |1100⟩
                Complex64::ZERO, // |1101⟩
                Complex64::ZERO, // |1110⟩
                Complex64::ZERO, // |1111⟩
            ],
            expected_state: vec![
                Complex64::ZERO, // |0000⟩
                Complex64::ZERO, // |0001⟩
                Complex64::ZERO, // |0010⟩
                Complex64::ZERO, // |0011⟩
                Complex64::ZERO, // |0100⟩
                Complex64::ZERO, // |0101⟩
                Complex64::ONE,  // |0110⟩
                Complex64::ZERO, // |0111⟩
                Complex64::ZERO, // |1000⟩
                Complex64::ZERO, // |1001⟩
                Complex64::ZERO, // |1010⟩
                Complex64::ZERO, // |1011⟩
                Complex64::ZERO, // |1100⟩
                Complex64::ZERO, // |1101⟩
                Complex64::ZERO, // |1110⟩
                Complex64::ZERO, // |1111⟩
            ],
        },
        // CC-QFT: Controls met (|1101> -> QFT|01>)
        TestVector {
            description: "CC-QFT: Controls met (|1101> -> QFT|01>)",
            qubits: vec![3, 2, 0, 1],
            num_controls: Some(2),
            args: (),
            initial_state: vec![
                Complex64::ZERO, // |0000⟩
                Complex64::ZERO, // |0001⟩
                Complex64::ZERO, // |0010⟩
                Complex64::ZERO, // |0011⟩
                Complex64::ZERO, // |0100⟩
                Complex64::ZERO, // |0101⟩
                Complex64::ZERO, // |0110⟩
                Complex64::ZERO, // |0111⟩
                Complex64::ZERO, // |1000⟩
                Complex64::ZERO, // |1001⟩
                Complex64::ZERO, // |1010⟩
                Complex64::ZERO, // |1011⟩
                Complex64::ZERO, // |1100⟩
                Complex64::ONE,  // |1101⟩
                Complex64::ZERO, // |1110⟩
                Complex64::ZERO, // |1111⟩
            ],
            expected_state: vec![
                Complex64::ZERO,           // |0000⟩
                Complex64::ZERO,           // |0001⟩
                Complex64::ZERO,           // |0010⟩
                Complex64::ZERO,           // |0011⟩
                Complex64::ZERO,           // |0100⟩
                Complex64::ZERO,           // |0101⟩
                Complex64::ZERO,           // |0110⟩
                Complex64::ZERO,           // |0111⟩
                Complex64::ZERO,           // |1000⟩
                Complex64::ZERO,           // |1001⟩
                Complex64::ZERO,           // |1010⟩
                Complex64::ZERO,           // |1011⟩
                Complex64::from(0.5),      // |1100⟩
                Complex64::new(0.0, 0.5),  // |1101⟩
                Complex64::from(-0.5),     // |1110⟩
                Complex64::new(0.0, -0.5), // |1111⟩
            ],
        },
        // CC-QFT: Superposition of met and not-met controls
        TestVector {
            description: "CC-QFT: Superposition of met and not-met controls",
            qubits: vec![3, 2, 0, 1],
            num_controls: Some(2),
            args: (),
            initial_state: vec![
                Complex64::ZERO,                // |0000⟩
                Complex64::ZERO,                // |0001⟩
                Complex64::ZERO,                // |0010⟩
                Complex64::ZERO,                // |0011⟩
                Complex64::ZERO,                // |0100⟩
                Complex64::ZERO,                // |0101⟩
                Complex64::from(FRAC_1_SQRT_2), // |0110⟩
                Complex64::ZERO,                // |0111⟩
                Complex64::ZERO,                // |1000⟩
                Complex64::ZERO,                // |1001⟩
                Complex64::ZERO,                // |1010⟩
                Complex64::ZERO,                // |1011⟩
                Complex64::ZERO,                // |1100⟩
                Complex64::from(FRAC_1_SQRT_2), // |1101⟩
                Complex64::ZERO,                // |1110⟩
                Complex64::ZERO,                // |1111⟩
            ],
            expected_state: vec![
                Complex64::ZERO,                           // |0000⟩
                Complex64::ZERO,                           // |0001⟩
                Complex64::ZERO,                           // |0010⟩
                Complex64::ZERO,                           // |0011⟩
                Complex64::ZERO,                           // |0100⟩
                Complex64::ZERO,                           // |0101⟩
                Complex64::from(FRAC_1_SQRT_2),            // |0110⟩
                Complex64::ZERO,                           // |0111⟩
                Complex64::ZERO,                           // |1000⟩
                Complex64::ZERO,                           // |1001⟩
                Complex64::ZERO,                           // |1010⟩
                Complex64::ZERO,                           // |1011⟩
                Complex64::from(0.35355339059327373),      // |1100⟩
                Complex64::new(0.0, 0.35355339059327373),  // |1101⟩
                Complex64::from(-0.35355339059327373),     // |1110⟩
                Complex64::new(0.0, -0.35355339059327373), // |1111⟩
            ],
        },
    ]
});

pub(crate) static CCQFT2_TESTS: LazyLock<Vec<TestVector<()>>> = LazyLock::new(|| {
    vec![
        // CC-QFT: Controls met (|1101> -> |11> (H|1> H|0>))
        TestVector {
            description: "CC-QFT: Controls met (|1101> -> |11> (H|1> H|0>))",
            qubits: vec![3, 2, 1, 0],
            num_controls: Some(2),
            args: (),
            initial_state: vec![
                Complex64::ZERO, // |0000⟩
                Complex64::ZERO, // |0001⟩
                Complex64::ZERO, // |0010⟩
                Complex64::ZERO, // |0011⟩
                Complex64::ZERO, // |0100⟩
                Complex64::ZERO, // |0101⟩
                Complex64::ZERO, // |0110⟩
                Complex64::ZERO, // |0111⟩
                Complex64::ZERO, // |1000⟩
                Complex64::ZERO, // |1001⟩
                Complex64::ZERO, // |1010⟩
                Complex64::ZERO, // |1011⟩
                Complex64::ZERO, // |1100⟩
                Complex64::ONE,  // |1101⟩
                Complex64::ZERO, // |1110⟩
                Complex64::ZERO, // |1111⟩
            ],
            expected_state: vec![
                Complex64::ZERO,       // |0000⟩
                Complex64::ZERO,       // |0001⟩
                Complex64::ZERO,       // |0010⟩
                Complex64::ZERO,       // |0011⟩
                Complex64::ZERO,       // |0100⟩
                Complex64::ZERO,       // |0101⟩
                Complex64::ZERO,       // |0110⟩
                Complex64::ZERO,       // |0111⟩
                Complex64::ZERO,       // |1000⟩
                Complex64::ZERO,       // |1001⟩
                Complex64::ZERO,       // |1010⟩
                Complex64::ZERO,       // |1011⟩
                Complex64::from(0.5),  // |1100⟩
                Complex64::from(0.5),  // |1101⟩
                Complex64::from(-0.5), // |1110⟩
                Complex64::from(-0.5), // |1111⟩
            ],
        },
        // CC-QFT: Superposition of met and not-met controls
        TestVector {
            description: "CC-QFT: Superposition of met and not-met controls",
            qubits: vec![3, 2, 1, 0],
            num_controls: Some(2),
            args: (),
            initial_state: vec![
                Complex64::ZERO,                // |0000⟩
                Complex64::ZERO,                // |0001⟩
                Complex64::ZERO,                // |0010⟩
                Complex64::ZERO,                // |0011⟩
                Complex64::ZERO,                // |0100⟩
                Complex64::ZERO,                // |0101⟩
                Complex64::from(FRAC_1_SQRT_2), // |0110⟩
                Complex64::ZERO,                // |0111⟩
                Complex64::ZERO,                // |1000⟩
                Complex64::ZERO,                // |1001⟩
                Complex64::ZERO,                // |1010⟩
                Complex64::ZERO,                // |1011⟩
                Complex64::ZERO,                // |1100⟩
                Complex64::from(FRAC_1_SQRT_2), // |1101⟩
                Complex64::ZERO,                // |1110⟩
                Complex64::ZERO,                // |1111⟩
            ],
            expected_state: vec![
                Complex64::ZERO,                       // |0000⟩
                Complex64::ZERO,                       // |0001⟩
                Complex64::ZERO,                       // |0010⟩
                Complex64::ZERO,                       // |0011⟩
                Complex64::ZERO,                       // |0100⟩
                Complex64::ZERO,                       // |0101⟩
                Complex64::from(FRAC_1_SQRT_2),        // |0110⟩
                Complex64::ZERO,                       // |0111⟩
                Complex64::ZERO,                       // |1000⟩
                Complex64::ZERO,                       // |1001⟩
                Complex64::ZERO,                       // |1010⟩
                Complex64::ZERO,                       // |1011⟩
                Complex64::from(0.35355339059327373),  // |1100⟩
                Complex64::from(0.35355339059327373),  // |1101⟩
                Complex64::from(-0.35355339059327373), // |1110⟩
                Complex64::from(-0.35355339059327373), // |1111⟩
            ],
        },
    ]
});

pub(crate) static CNOT_TESTS: LazyLock<Vec<TestVector<()>>> = LazyLock::new(|| {
    vec![
        // |10⟩ → |11⟩
        TestVector {
            description: "|10⟩ → |11⟩",
            qubits: vec![1, 0],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ZERO, // |00⟩
                Complex64::ZERO, // |01⟩
                Complex64::ONE,  // |10⟩
                Complex64::ZERO, // |11⟩
            ],
            expected_state: vec![
                Complex64::ZERO, // |00⟩
                Complex64::ZERO, // |01⟩
                Complex64::ZERO, // |10⟩
                Complex64::ONE,  // |11⟩
            ],
        },
        // |11⟩ → |10⟩
        TestVector {
            description: "|11⟩ → |10⟩",
            qubits: vec![1, 0],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ZERO, // |00⟩
                Complex64::ZERO, // |01⟩
                Complex64::ZERO, // |10⟩
                Complex64::ONE,  // |11⟩
            ],
            expected_state: vec![
                Complex64::ZERO, // |00⟩
                Complex64::ZERO, // |01⟩
                Complex64::ONE,  // |10⟩
                Complex64::ZERO, // |11⟩
            ],
        },
        // Superposition |10⟩ + |11⟩ → |11⟩ + |10⟩
        TestVector {
            description: "Superposition |10⟩ + |11⟩ → |11⟩ + |10⟩",
            qubits: vec![1, 0],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ZERO,                // |00⟩
                Complex64::ZERO,                // |01⟩
                Complex64::from(FRAC_1_SQRT_2), // |10⟩
                Complex64::from(FRAC_1_SQRT_2), // |11⟩
            ],
            expected_state: vec![
                Complex64::ZERO,                // |00⟩
                Complex64::ZERO,                // |01⟩
                Complex64::from(FRAC_1_SQRT_2), // |10⟩
                Complex64::from(FRAC_1_SQRT_2), // |11⟩
            ],
        },
        // Bell State |Φ+⟩ = Superposition |00⟩ + |11⟩ → |00⟩ + |10⟩
        TestVector {
            description: "Bell State |Φ+⟩ = Superposition |00⟩ + |11⟩ → |00⟩ + |10⟩",
            qubits: vec![1, 0],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::from(FRAC_1_SQRT_2), // |00⟩
                Complex64::ZERO,                // |01⟩
                Complex64::ZERO,                // |10⟩
                Complex64::from(FRAC_1_SQRT_2), // |11⟩
            ],
            expected_state: vec![
                Complex64::from(FRAC_1_SQRT_2), // |00⟩
                Complex64::ZERO,                // |01⟩
                Complex64::from(FRAC_1_SQRT_2), // |10⟩
                Complex64::ZERO,                // |11⟩
            ],
        },
        // |00⟩ remains |00⟩
        TestVector {
            description: "|00⟩ remains |00⟩",
            qubits: vec![1, 0],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ONE,  // |00⟩
                Complex64::ZERO, // |01⟩
                Complex64::ZERO, // |10⟩
                Complex64::ZERO, // |11⟩
            ],
            expected_state: vec![
                Complex64::ONE,  // |00⟩
                Complex64::ZERO, // |01⟩
                Complex64::ZERO, // |10⟩
                Complex64::ZERO, // |11⟩
            ],
        },
    ]
});

pub(crate) static CQFT_TESTS: LazyLock<Vec<TestVector<()>>> = LazyLock::new(|| {
    vec![
        // Controlled-QFT
        TestVector {
            description: "Controlled-QFT",
            qubits: vec![2, 0, 1],
            num_controls: Some(1),
            args: (),
            initial_state: vec![
                Complex64::from(FRAC_1_SQRT_2), // |000⟩
                Complex64::ZERO,                // |001⟩
                Complex64::ZERO,                // |010⟩
                Complex64::ZERO,                // |011⟩
                Complex64::ZERO,                // |100⟩
                Complex64::from(FRAC_1_SQRT_2), // |101⟩
                Complex64::ZERO,                // |110⟩
                Complex64::ZERO,                // |111⟩
            ],
            expected_state: vec![
                Complex64::from(FRAC_1_SQRT_2),            // |000⟩
                Complex64::ZERO,                           // |001⟩
                Complex64::ZERO,                           // |010⟩
                Complex64::ZERO,                           // |011⟩
                Complex64::from(0.35355339059327373),      // |100⟩
                Complex64::new(0.0, 0.35355339059327373),  // |101⟩
                Complex64::from(-0.35355339059327373),     // |110⟩
                Complex64::new(0.0, -0.35355339059327373), // |111⟩
            ],
        },
    ]
});

pub(crate) static FREDKIN_TESTS: LazyLock<Vec<TestVector<()>>> = LazyLock::new(|| {
    vec![
        // |000⟩ → |000⟩ (No Swap)
        TestVector {
            description: "|000⟩ → |000⟩ (No Swap)",
            qubits: vec![2, 0, 1],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ONE,  // |000⟩
                Complex64::ZERO, // |001⟩
                Complex64::ZERO, // |010⟩
                Complex64::ZERO, // |011⟩
                Complex64::ZERO, // |100⟩
                Complex64::ZERO, // |101⟩
                Complex64::ZERO, // |110⟩
                Complex64::ZERO, // |111⟩
            ],
            expected_state: vec![
                Complex64::ONE,  // |000⟩
                Complex64::ZERO, // |001⟩
                Complex64::ZERO, // |010⟩
                Complex64::ZERO, // |011⟩
                Complex64::ZERO, // |100⟩
                Complex64::ZERO, // |101⟩
                Complex64::ZERO, // |110⟩
                Complex64::ZERO, // |111⟩
            ],
        },
        // |100⟩ → |110⟩ (Swap)
        TestVector {
            description: "|100⟩ → |110⟩ (Swap)",
            qubits: vec![2, 0, 1],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ZERO, // |000⟩
                Complex64::ZERO, // |001⟩
                Complex64::ZERO, // |010⟩
                Complex64::ZERO, // |011⟩
                Complex64::ZERO, // |100⟩
                Complex64::ONE,  // |101⟩
                Complex64::ZERO, // |110⟩
                Complex64::ZERO, // |111⟩
            ],
            expected_state: vec![
                Complex64::ZERO, // |000⟩
                Complex64::ZERO, // |001⟩
                Complex64::ZERO, // |010⟩
                Complex64::ZERO, // |011⟩
                Complex64::ZERO, // |100⟩
                Complex64::ZERO, // |101⟩
                Complex64::ONE,  // |110⟩
                Complex64::ZERO, // |111⟩
            ],
        },
        // |110⟩ → |101⟩ (Swap)
        TestVector {
            description: "|110⟩ → |101⟩ (Swap)",
            qubits: vec![2, 0, 1],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ZERO, // |000⟩
                Complex64::ZERO, // |001⟩
                Complex64::ZERO, // |010⟩
                Complex64::ZERO, // |011⟩
                Complex64::ZERO, // |100⟩
                Complex64::ZERO, // |101⟩
                Complex64::ONE,  // |110⟩
                Complex64::ZERO, // |111⟩
            ],
            expected_state: vec![
                Complex64::ZERO, // |000⟩
                Complex64::ZERO, // |001⟩
                Complex64::ZERO, // |010⟩
                Complex64::ZERO, // |011⟩
                Complex64::ZERO, // |100⟩
                Complex64::ONE,  // |101⟩
                Complex64::ZERO, // |110⟩
                Complex64::ZERO, // |111⟩
            ],
        },
        // Superposition |101⟩ + |110⟩ → |110⟩ + |101⟩ (No observable change)
        TestVector {
            description: "Superposition |101⟩ + |110⟩ → |110⟩ + |101⟩ (No observable change)",
            qubits: vec![2, 0, 1],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ZERO,                // |000⟩
                Complex64::ZERO,                // |001⟩
                Complex64::ZERO,                // |010⟩
                Complex64::ZERO,                // |011⟩
                Complex64::ZERO,                // |100⟩
                Complex64::from(FRAC_1_SQRT_2), // |101⟩
                Complex64::from(FRAC_1_SQRT_2), // |110⟩
                Complex64::ZERO,                // |111⟩
            ],
            expected_state: vec![
                Complex64::ZERO,                // |000⟩
                Complex64::ZERO,                // |001⟩
                Complex64::ZERO,                // |010⟩
                Complex64::ZERO,                // |011⟩
                Complex64::ZERO,                // |100⟩
                Complex64::from(FRAC_1_SQRT_2), // |101⟩
                Complex64::from(FRAC_1_SQRT_2), // |110⟩
                Complex64::ZERO,                // |111⟩
            ],
        },
    ]
});

pub(crate) static HADAMARD_TESTS: LazyLock<Vec<TestVector<()>>> = LazyLock::new(|| {
    vec![
        // |0⟩ → (|0⟩ + |1⟩)/sqrt(2)
        TestVector {
            description: "|0⟩ → (|0⟩ + |1⟩)/sqrt(2)",
            qubits: vec![0],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ONE,  // |0⟩
                Complex64::ZERO, // |1⟩
            ],
            expected_state: vec![
                Complex64::from(FRAC_1_SQRT_2), // |0⟩
                Complex64::from(FRAC_1_SQRT_2), // |1⟩
            ],
        },
        // |1⟩ → (|0⟩ - |1⟩)/sqrt(2)
        TestVector {
            description: "|1⟩ → (|0⟩ - |1⟩)/sqrt(2)",
            qubits: vec![0],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ZERO, // |0⟩
                Complex64::ONE,  // |1⟩
            ],
            expected_state: vec![
                Complex64::from(FRAC_1_SQRT_2),  // |0⟩
                Complex64::from(-FRAC_1_SQRT_2), // |1⟩
            ],
        },
        // Superposition |+⟩ = (|0⟩ + |1⟩)/sqrt(2) → |0⟩
        TestVector {
            description: "Superposition |+⟩ = (|0⟩ + |1⟩)/sqrt(2) → |0⟩",
            qubits: vec![0],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::from(FRAC_1_SQRT_2), // |0⟩
                Complex64::from(FRAC_1_SQRT_2), // |1⟩
            ],
            expected_state: vec![
                Complex64::ONE,  // |0⟩
                Complex64::ZERO, // |1⟩
            ],
        },
    ]
});

pub(crate) static NOT_TESTS: LazyLock<Vec<TestVector<()>>> = LazyLock::new(|| {
    vec![
        // |0⟩ → |1⟩
        TestVector {
            description: "|0⟩ → |1⟩",
            qubits: vec![0],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ONE,  // |0⟩
                Complex64::ZERO, // |1⟩
            ],
            expected_state: vec![
                Complex64::ZERO, // |0⟩
                Complex64::ONE,  // |1⟩
            ],
        },
        // |1⟩ → |0⟩
        TestVector {
            description: "|1⟩ → |0⟩",
            qubits: vec![0],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ZERO, // |0⟩
                Complex64::ONE,  // |1⟩
            ],
            expected_state: vec![
                Complex64::ONE,  // |0⟩
                Complex64::ZERO, // |1⟩
            ],
        },
        //  Superposition |+⟩ = (|0⟩ + |1⟩)/sqrt(2) → (|1⟩ + |0⟩)/sqrt(2)
        TestVector {
            description: " Superposition |+⟩ = (|0⟩ + |1⟩)/sqrt(2) → (|1⟩ + |0⟩)/sqrt(2)",
            qubits: vec![0],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::from(FRAC_1_SQRT_2), // |0⟩
                Complex64::from(FRAC_1_SQRT_2), // |1⟩
            ],
            expected_state: vec![
                Complex64::from(FRAC_1_SQRT_2), // |0⟩
                Complex64::from(FRAC_1_SQRT_2), // |1⟩
            ],
        },
    ]
});

pub(crate) static PHASE_TESTS: LazyLock<Vec<TestVector<PhaseArgs>>> = LazyLock::new(|| {
    vec![
        // Phase shift by π/2 on |1⟩ → i|1⟩
        TestVector {
            description: "Phase shift by π/2 on |1⟩ → i|1⟩",
            qubits: vec![0],
            num_controls: None,
            args: PhaseArgs { fraction: 0.25 },
            initial_state: vec![
                Complex64::ONE,  // |0⟩
                Complex64::ZERO, // |1⟩
            ],
            expected_state: vec![
                Complex64::ONE,  // |0⟩
                Complex64::ZERO, // |1⟩
            ],
        },
        // Phase shift by π/2 on |1⟩ → i|1⟩
        TestVector {
            description: "Phase shift by π/2 on |1⟩ → i|1⟩",
            qubits: vec![0],
            num_controls: None,
            args: PhaseArgs { fraction: 0.25 },
            initial_state: vec![
                Complex64::ZERO, // |0⟩
                Complex64::ONE,  // |1⟩
            ],
            expected_state: vec![
                Complex64::ZERO, // |0⟩
                Complex64::I,    // |1⟩
            ],
        },
        // Phase shift by π on |1⟩ → -|1⟩
        TestVector {
            description: "Phase shift by π on |1⟩ → -|1⟩",
            qubits: vec![0],
            num_controls: None,
            args: PhaseArgs { fraction: 0.5 },
            initial_state: vec![
                Complex64::ZERO, // |0⟩
                Complex64::ONE,  // |1⟩
            ],
            expected_state: vec![
                Complex64::ZERO, // |0⟩
                -Complex64::ONE, // |1⟩
            ],
        },
        // Phase shift by π/4 on |1⟩ → (1 + i)/sqrt(2)|1⟩
        TestVector {
            description: "Phase shift by π/4 on |1⟩ → (1 + i)/sqrt(2)|1⟩",
            qubits: vec![0],
            num_controls: None,
            args: PhaseArgs { fraction: 0.125 },
            initial_state: vec![
                Complex64::ZERO, // |0⟩
                Complex64::ONE,  // |1⟩
            ],
            expected_state: vec![
                Complex64::ZERO,                              // |0⟩
                Complex64::new(FRAC_1_SQRT_2, FRAC_1_SQRT_2), // |1⟩
            ],
        },
    ]
});

pub(crate) static QFT_TESTS: LazyLock<Vec<TestVector<()>>> = LazyLock::new(|| {
    vec![
        // |0⟩ + |2⟩ → |0⟩ + |2⟩
        TestVector {
            description: "|0⟩ + |2⟩ → |0⟩ + |2⟩",
            qubits: vec![0, 1],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::from(FRAC_1_SQRT_2), // |00⟩
                Complex64::ZERO,                // |01⟩
                Complex64::from(FRAC_1_SQRT_2), // |10⟩
                Complex64::ZERO,                // |11⟩
            ],
            expected_state: vec![
                Complex64::from(FRAC_1_SQRT_2), // |00⟩
                Complex64::ZERO,                // |01⟩
                Complex64::from(FRAC_1_SQRT_2), // |10⟩
                Complex64::ZERO,                // |11⟩
            ],
        },
        // |0⟩ + |2⟩ + |4⟩ + |6⟩ → |0⟩ + |4⟩
        TestVector {
            description: "|0⟩ + |2⟩ + |4⟩ + |6⟩ → |0⟩ + |4⟩",
            qubits: vec![0, 1, 2],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::from(0.5), // |000⟩
                Complex64::ZERO,      // |001⟩
                Complex64::from(0.5), // |010⟩
                Complex64::ZERO,      // |011⟩
                Complex64::from(0.5), // |100⟩
                Complex64::ZERO,      // |101⟩
                Complex64::from(0.5), // |110⟩
                Complex64::ZERO,      // |111⟩
            ],
            expected_state: vec![
                Complex64::from(FRAC_1_SQRT_2), // |000⟩
                Complex64::ZERO,                // |001⟩
                Complex64::ZERO,                // |010⟩
                Complex64::ZERO,                // |011⟩
                Complex64::from(FRAC_1_SQRT_2), // |100⟩
                Complex64::ZERO,                // |101⟩
                Complex64::ZERO,                // |110⟩
                Complex64::ZERO,                // |111⟩
            ],
        },
        // |1⟩ + |5⟩ + |9⟩ + |13⟩ → |0⟩ + |4⟩ + |8⟩ + |12⟩
        TestVector {
            description: "|1⟩ + |5⟩ + |9⟩ + |13⟩ → |0⟩ + |4⟩ + |8⟩ + |12⟩",
            qubits: vec![0, 1, 2, 3],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ZERO,      // |0000⟩
                Complex64::from(0.5), // |0001⟩
                Complex64::ZERO,      // |0010⟩
                Complex64::ZERO,      // |0011⟩
                Complex64::ZERO,      // |0100⟩
                Complex64::from(0.5), // |0101⟩
                Complex64::ZERO,      // |0110⟩
                Complex64::ZERO,      // |0111⟩
                Complex64::ZERO,      // |1000⟩
                Complex64::from(0.5), // |1001⟩
                Complex64::ZERO,      // |1010⟩
                Complex64::ZERO,      // |1011⟩
                Complex64::ZERO,      // |1100⟩
                Complex64::from(0.5), // |1101⟩
                Complex64::ZERO,      // |1110⟩
                Complex64::ZERO,      // |1111⟩
            ],
            expected_state: vec![
                Complex64::from(0.5),      // |0000⟩
                Complex64::ZERO,           // |0001⟩
                Complex64::ZERO,           // |0010⟩
                Complex64::ZERO,           // |0011⟩
                Complex64::new(0.0, 0.5),  // |0100⟩
                Complex64::ZERO,           // |0101⟩
                Complex64::ZERO,           // |0110⟩
                Complex64::ZERO,           // |0111⟩
                Complex64::from(-0.5),     // |1000⟩
                Complex64::ZERO,           // |1001⟩
                Complex64::ZERO,           // |1010⟩
                Complex64::ZERO,           // |1011⟩
                Complex64::new(0.0, -0.5), // |1100⟩
                Complex64::ZERO,           // |1101⟩
                Complex64::ZERO,           // |1110⟩
                Complex64::ZERO,           // |1111⟩
            ],
        },
    ]
});

pub(crate) static SWAP_TESTS: LazyLock<Vec<TestVector<()>>> = LazyLock::new(|| {
    vec![
        // |01⟩ → |10⟩
        TestVector {
            description: "|01⟩ → |10⟩",
            qubits: vec![0, 1],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ZERO, // |00⟩
                Complex64::ONE,  // |01⟩
                Complex64::ZERO, // |10⟩
                Complex64::ZERO, // |11⟩
            ],
            expected_state: vec![
                Complex64::ZERO, // |00⟩
                Complex64::ZERO, // |01⟩
                Complex64::ONE,  // |10⟩
                Complex64::ZERO, // |11⟩
            ],
        },
        // |00⟩ and |11⟩ remain unchanged
        TestVector {
            description: "|00⟩ and |11⟩ remain unchanged",
            qubits: vec![0, 1],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::from(FRAC_1_SQRT_2), // |00⟩
                Complex64::ZERO,                // |01⟩
                Complex64::ZERO,                // |10⟩
                Complex64::from(FRAC_1_SQRT_2), // |11⟩
            ],
            expected_state: vec![
                Complex64::from(FRAC_1_SQRT_2), // |00⟩
                Complex64::ZERO,                // |01⟩
                Complex64::ZERO,                // |10⟩
                Complex64::from(FRAC_1_SQRT_2), // |11⟩
            ],
        },
        // Superposition |01⟩ + |10⟩ → |10⟩ + |01⟩
        TestVector {
            description: "Superposition |01⟩ + |10⟩ → |10⟩ + |01⟩",
            qubits: vec![0, 1],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ZERO,                // |00⟩
                Complex64::from(FRAC_1_SQRT_2), // |01⟩
                Complex64::from(FRAC_1_SQRT_2), // |10⟩
                Complex64::ZERO,                // |11⟩
            ],
            expected_state: vec![
                Complex64::ZERO,                // |00⟩
                Complex64::from(FRAC_1_SQRT_2), // |01⟩
                Complex64::from(FRAC_1_SQRT_2), // |10⟩
                Complex64::ZERO,                // |11⟩
            ],
        },
    ]
});

pub(crate) static TOFFOLI_TESTS: LazyLock<Vec<TestVector<()>>> = LazyLock::new(|| {
    vec![
        // |110⟩ → |111⟩
        TestVector {
            description: "|110⟩ → |111⟩",
            qubits: vec![1, 2, 0],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ZERO, // |000⟩
                Complex64::ZERO, // |001⟩
                Complex64::ZERO, // |010⟩
                Complex64::ZERO, // |011⟩
                Complex64::ZERO, // |100⟩
                Complex64::ZERO, // |101⟩
                Complex64::ONE,  // |110⟩
                Complex64::ZERO, // |111⟩
            ],
            expected_state: vec![
                Complex64::ZERO, // |000⟩
                Complex64::ZERO, // |001⟩
                Complex64::ZERO, // |010⟩
                Complex64::ZERO, // |011⟩
                Complex64::ZERO, // |100⟩
                Complex64::ZERO, // |101⟩
                Complex64::ZERO, // |110⟩
                Complex64::ONE,  // |111⟩
            ],
        },
        // |110⟩ → |110⟩
        TestVector {
            description: "|110⟩ → |110⟩",
            qubits: vec![1, 2, 0],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ZERO, // |000⟩
                Complex64::ZERO, // |001⟩
                Complex64::ZERO, // |010⟩
                Complex64::ZERO, // |011⟩
                Complex64::ZERO, // |100⟩
                Complex64::ZERO, // |101⟩
                Complex64::ZERO, // |110⟩
                Complex64::ONE,  // |111⟩
            ],
            expected_state: vec![
                Complex64::ZERO, // |000⟩
                Complex64::ZERO, // |001⟩
                Complex64::ZERO, // |010⟩
                Complex64::ZERO, // |011⟩
                Complex64::ZERO, // |100⟩
                Complex64::ZERO, // |101⟩
                Complex64::ONE,  // |110⟩
                Complex64::ZERO, // |111⟩
            ],
        },
        // Superposition |110⟩ + |111⟩ → |111⟩ + |110⟩
        TestVector {
            description: "Superposition |110⟩ + |111⟩ → |111⟩ + |110⟩",
            qubits: vec![1, 2, 0],
            num_controls: None,
            args: (),
            initial_state: vec![
                Complex64::ZERO,                // |000⟩
                Complex64::ZERO,                // |001⟩
                Complex64::ZERO,                // |010⟩
                Complex64::ZERO,                // |011⟩
                Complex64::ZERO,                // |100⟩
                Complex64::ZERO,                // |101⟩
                Complex64::from(FRAC_1_SQRT_2), // |110⟩
                Complex64::from(FRAC_1_SQRT_2), // |111⟩
            ],
            expected_state: vec![
                Complex64::ZERO,                // |000⟩
                Complex64::ZERO,                // |001⟩
                Complex64::ZERO,                // |010⟩
                Complex64::ZERO,                // |011⟩
                Complex64::ZERO,                // |100⟩
                Complex64::ZERO,                // |101⟩
                Complex64::from(FRAC_1_SQRT_2), // |110⟩
                Complex64::from(FRAC_1_SQRT_2), // |111⟩
            ],
        },
    ]
});
